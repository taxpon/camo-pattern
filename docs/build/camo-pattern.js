class t{constructor(t){this.ctx=t}drawCircle(t){this.ctx.fillStyle=t.color,this.ctx.beginPath(),this.ctx.arc(t.center.x,t.center.y,t.radius,0,2*Math.PI,!0),this.ctx.closePath(),this.ctx.fill()}drawPolygon(t,e,s){e?(this.ctx.fillStyle=e,this.ctx.strokeStyle=s||e):(this.ctx.fillStyle=t.color,this.ctx.strokeStyle=t.strokeColor||t.color),this.ctx.beginPath(),t.points.forEach(((t,e)=>{0===e?this.ctx.moveTo(...t.coord):this.ctx.lineTo(...t.coord)})),this.ctx.closePath(),this.ctx.stroke(),this.ctx.fill()}}class e{constructor(t,e,s=null){this._x=t,this._y=e,this._index=s}get coord(){return[this._x,this._y]}get x(){return this._x}set x(t){this._x=t}get y(){return this._y}set y(t){this._y=t}get key(){return`${this.x},${this.y}`}get hasIndex(){return!!this._index}get keyIndex(){return this._index}dist(t){return Math.sqrt(Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2))}equals(t){return this.x===t.x&&this.y===t.y}div(t){return this.x/=t,this.y/=t,this}static of(t,s){let i=`${t},${s}`;return void 0===this._cache[i]&&(this._cache[i]=new e(t,s)),this._cache[i]}static randomOf(t=0,s=0,i,n){return e.of(t+Math.random()*i,s+Math.random()*n)}static randomPointsOf(t,s,i,n){let r=[];for(let t=0;t<n;t++)r.push(2*Math.PI*Math.random());return r.sort(),r.map((n=>e.of(t+i*Math.cos(n),s+i*Math.sin(n))))}static randomPoints2Of(t,s,i,n){let r=[],a=2*Math.PI*Math.random();for(let t=0;t<n;t++){let e=1.5*Math.random()-.75,s=2*Math.PI/n*t+e;r.push(s+a)}return r.sort(),r.map((n=>e.of(t+i*Math.cos(n),s+i*Math.sin(n))))}}e._cache={};class s{constructor(t,s,i){this._points=t,this._color=s,this._strokeColor=i,this._center=this._points.reduce(((t,s,i,n)=>new e(t.x+s.x,t.y+s.y))).div(this._points.length),this._points.sort(this.comparePoints.bind(this)),this.setMinMax()}get points(){return this._points}get color(){return this._color}set color(t){this._color=t}get strokeColor(){return this._strokeColor}set strokeColor(t){this._strokeColor=t}get key(){return this.points.map((t=>t.key)).join("/")}get keyIndex(){return this.points.map((t=>t.keyIndex.toString())).join("/")}equals(t){if(this.points.length!=t.points.length)return!1;for(let e=0;e<this.points.length;e++)if(!this.points[e].equals(t.points[e]))return!1;return!0}isContaining(t){let e=!1;if(t.x<this.minX||t.x>this.maxX||t.y<this.minY||t.y>this.maxY)return!1;for(let s=0,i=this.points.length-1;s<this.points.length;i=s++)this.points[s].y>t.y!=this.points[i].y>t.y&&t.x<(this.points[i].x-this.points[s].x)*(t.y-this.points[s].y)/(this.points[i].y-this.points[s].y)+this.points[s].x&&(e=!e);return e}setMinMax(){this.minX=this.points[0].x,this.maxX=this.points[0].x,this.minY=this.points[0].y,this.maxY=this.points[0].y;for(let t=1;t<this.points.length;t++){let e=this.points[t];this.minX=Math.min(e.x,this.minX),this.maxX=Math.max(e.x,this.maxX),this.minY=Math.min(e.y,this.minY),this.maxY=Math.max(e.y,this.maxY)}}comparePoints(t,e){if(t.equals(e))return 0;return(()=>{if(t.x-this._center.x>=0&&e.x-this._center.x<0)return!0;if(t.x-this._center.x<0&&e.x-this._center.x>=0)return!1;if(t.x-this._center.x==0&&e.x-this._center.x==0)return t.y-this._center.y>=0||e.y-this._center.y>=0?t.y>e.y:e.y>t.y;let s=(t.x-this._center.x)*(e.y-this._center.y)-(e.x-this._center.x)*(t.y-this._center.y);return s<0||!(s>0)&&(t.x-this._center.x)*(t.x-this._center.x)+(t.y-this._center.y)*(t.y-this._center.y)>(e.x-this._center.x)*(e.x-this._center.x)+(e.y-this._center.y)*(e.y-this._center.y)})()?1:-1}}class i extends t{startAnimate(){}stopAnimate(){}handleMouseMove(t){}draw(t,i,n){const r=500;let a=Math.ceil(t/r),h=Math.ceil(i/r);for(let t=0;t<a;t++)for(let i=0;i<h;i++){let a=r*t,h=r*i,o=n.next(),l=4,c=Math.random();if(c>.66?l=5:c>.33&&(l=6),Math.random()>.8)continue;let d=new s(e.randomPoints2Of(a,h,r,l),o.value);this.drawPolygon(d)}const o=200;a=Math.ceil(t/o),h=Math.ceil(i/o);for(let t=0;t<a;t++)for(let i=0;i<h;i++){let r=o*t,a=o*i,h=n.next(),l=4,c=Math.random();if(c>.66?l=5:c>.33&&(l=6),Math.random()>.8)continue;let d=new s(e.randomPoints2Of(r,a,o,l),h.value);this.drawPolygon(d)}}}class n{constructor(t,e,s){this._center=t,this._radius=e,this._color=s}get center(){return this._center}get radius(){return this._radius}get color(){return this._color}isContaining(t){return this.center.dist(t)<this.radius}}class r{}r.range=(t,e)=>Array.from({length:e-t+1},((e,s)=>s+t));class a{constructor(t,e){t.hasIndex&&e.hasIndex?t.keyIndex<e.keyIndex?(this._start=t,this._end=e):(this._start=e,this._end=t):t.x<=e.x?(this._start=t,this._end=e):(this._start=e,this._end=t)}get start(){return this._start}get end(){return this._end}get key(){return`${this.start.key}/${this.end.key}`}get keyIndex(){return`${this.start.keyIndex}-${this.end.keyIndex}`}equals(t){return this._start.equals(t._start)&&this._end.equals(t._end)||this._start.equals(t._end)&&this._end.equals(t._start)}}class h extends s{constructor(t,e){if(3!=t.length)throw Error("Triangle must have 3 points");super(t,e)}get area(){return this._area||(this._area=Math.abs(.5*(this.points[0].x*(this.points[1].y-this.points[2].y)+this.points[1].x*(this.points[2].y-this.points[0].y)+this.points[2].x*(this.points[0].y-this.points[1].y)))),this._area}get edges(){return this._edges||(this._edges=[],this._edges.push(new a(this.points[0],this.points[1])),this._edges.push(new a(this.points[1],this.points[2])),this._edges.push(new a(this.points[2],this.points[0]))),this._edges}getCircumcircle(){if(!this._circumcircle){const t=this.points[0].x,s=this.points[0].y,i=this.points[1].x,r=this.points[1].y,a=this.points[2].x,h=this.points[2].y,o=Math.pow(t,2),l=Math.pow(i,2),c=Math.pow(a,2),d=Math.pow(s,2),u=Math.pow(r,2),g=Math.pow(h,2),p=2*((i-t)*(h-s)-(r-s)*(a-t)),_=((h-s)*(l-o+u-d)+(s-r)*(c-o+g-d))/p,x=((t-a)*(l-o+u-d)+(i-t)*(c-o+g-d))/p,y=Math.sqrt(Math.pow(t-_,2)+Math.pow(s-x,2));this._circumcircle=new n(new e(_,x),y,"white")}return this._circumcircle}}class o{static incrementAndGet(){return void 0===this._index&&(this._index=0),this._index++}static reset(){this._index=0}}class l{constructor(t,e,s){this._id=t,this._name=e,this._colors=s}get id(){return this._id}get name(){return this._name}get colors(){return this._colors}}class c{static loadDefaultPalettes(){c._defaultPalettes=new Map,c._defaultPalettes.set("green",new l("green","Green",["#6C7C52","#4A4F44","#3B3845","#B2B096"])),c._defaultPalettes.set("desert",new l("desert","Desert",["#B8A79B","#72625D","#A69887","#6D4C2D"])),c._defaultPalettes.set("uc1",new l("uc1","UC1",["#C4B9B5","#683A31","#4A5F56"])),c._defaultPalettes.set("uc2",new l("uc2","UC2",["#262527","#513A3E","#424B50"]))}static loadUserPalettes(){this._userPalettes=new Map;JSON.parse(window.localStorage.getItem("userPalettes")||"[]").forEach((t=>{const e=new l(t._id,t._name,t._colors);this._userPalettes.set(e.id,e)}))}static saveUserPalettes(){let t=[];this._userPalettes.forEach((e=>{t.push(e)})),window.localStorage.setItem("userPalettes",JSON.stringify(t))}static setUserPalette(t){this._userPalettes.set(t.id,t),this.saveUserPalettes()}static deleteUserPalette(t){this._userPalettes.delete(t),this.saveUserPalettes()}static getDefaultPalettes(){return this._defaultPalettes}static getUserPalettes(){return this._userPalettes}static getBaseColorFromPalette(t){return(this._defaultPalettes.get(t)||this._userPalettes.get(t)).colors[0]}static colorGeneratorFromPalette(t){return this.colorGenerator((this._defaultPalettes.get(t)||this._userPalettes.get(t)).colors)}static*colorGenerator(t){for(;;){let e=this.range(0,t.length-1);for(let t=e.length;1<t;t--){let s=Math.floor(Math.random()*t);[e[s],e[t-1]]=[e[t-1],e[s]]}for(let s=0;s<e.length;s++)yield t[e[s]]}}static*colorGenerator2(t){for(;;){let e=this.range(0,t.length-1);for(let t=e.length;1<t;t--){let s=Math.floor(Math.random()*t);[e[s],e[t-1]]=[e[t-1],e[s]]}for(let s=0;s<e.length;s++)yield[t[e[s]],s]}}}c.ctor=(c.loadDefaultPalettes(),void c.loadUserPalettes()),c.range=(t,e)=>Array.from({length:e-t+1},((e,s)=>s+t));class d extends t{constructor(t){super(t),this.activeTriangle=new Array(2)}draw(t,s,i,a){let l;l=Array.isArray(i)?c.colorGenerator(i):i,this.points=[];const d=Math.ceil(t/500),u=Math.ceil(s/500);if(a.skipPointGeneration&&this.triangles){this.visitMap={};for(let t=0;t<this.triangles.length;t++){const e=this.triangles[t];this.visitMap[e.keyIndex]||this.makeCamouflage(e,l.next().value,a.camo_depth)}return}o.reset();for(let i=0;i<d+1;i++)for(let n=0;n<u+1;n++)this.points.push(new e(t/d*i,s/u*n,o.incrementAndGet()));let g=a.num_points-1;r.range(0,g).forEach(((i,n)=>{this.points.push(new e(Math.random()*t,Math.random()*s,o.incrementAndGet()))}));const p=Math.sqrt(t*t+s*s)/2,_=new e(t/2,s/2);this.drawCircle(new n(_,p,"rgba(1, 1, 1, 0)"));const x=new e(_.x-Math.sqrt(3)*p,_.y-p,o.incrementAndGet()),y=new e(_.x+Math.sqrt(3)*p,_.y-p,o.incrementAndGet()),m=new e(_.x,_.y+2*p,o.incrementAndGet()),f=new h([x,y,m],"pink");l.next();let M=[f];this.points.forEach(((t,e)=>{let s=[];M.forEach(((e,i)=>{e.getCircumcircle().isContaining(t)&&(s=s.concat(e.edges),delete M[i])})),s.map(((t,e)=>{for(let i=0;i<s.length;i++)if(e!=i&&t.equals(s[i]))return null;return t})).filter((t=>t)).forEach((e=>{M.push(new h([e.start,e.end,t],l.next().value))}))})),this.triangles=M.filter((t=>t)),this.triangleAreas=this.triangles.map((t=>t.area)).sort(((t,e)=>t-e)),this.triangleAreaMedian=this.triangleAreas[Math.floor(this.triangleAreas.length/2)],this.buildEdgeMap(),this.visitMap={};for(let t=0;t<this.triangles.length;t++){const e=this.triangles[t];this.visitMap[e.keyIndex]||this.makeCamouflage(e,l.next().value,a.camo_depth)}}makeCamouflage(t,e,s,i=null){if(i=i||s,t.color=e,this.visitMap[t.keyIndex]=e,0==s)return void this.drawPolygon(t,e);let n=s===i,r=[];t.edges.forEach(((a,h)=>{const o=this.edgeMap[a.keyIndex].filter((e=>!e.equals(t)))[0];o&&r.push(o),o&&!this.visitMap[o.keyIndex]&&(n=!1,(o.area<5e3||Math.random()<s/i)&&this.makeCamouflage(o,e,s-1,i))})),n?0==r.length?console.error("Failed to find adjacentTriangle"):(t.color=this.visitMap[r[0].keyIndex],this.drawPolygon(t,t.color,t.color)):this.drawPolygon(t,e)}startAnimate(){this.interval=setInterval(this.animate.bind(this),50)}stopAnimate(){clearInterval(this.interval)}animate(){this.points.forEach(((t,e)=>{this.points[e].x+=4*(Math.random()-.5),this.points[e].y+=4*(Math.random()-.5)})),this.triangles.forEach((t=>{this.isActiveTriangle(t)?this.drawPolygon(t,"red"):this.adjacentPolygons&&this.adjacentPolygons[t.keyIndex]?this.drawPolygon(t,"blue"):this.drawPolygon(t)}))}handleMouseMove(t){this.triangles.forEach((e=>{e.isContaining(t)?(this.updateActiveTriangle(e),this.drawPolygon(e,"red")):this.drawPolygon(e)})),Object.keys(this.adjacentPolygons).forEach((t=>{this.drawPolygon(this.adjacentPolygons[t],"blue")}))}buildEdgeMap(){this.edgeMap={},this.triangles.forEach((t=>{t.edges.forEach((e=>{void 0===this.edgeMap[e.keyIndex]&&(this.edgeMap[e.keyIndex]=[]),this.edgeMap[e.keyIndex].push(t)})),this.drawPolygon(t)}))}updateActiveTriangle(t){if(!this.isActiveTriangle(t)){this.activeTriangle[1]=this.activeTriangle[0],this.activeTriangle[0]=t,this.adjacentPolygons={};for(let e=0;e<t.edges.length;e++){const s=this.edgeMap[t.edges[e].keyIndex];s&&s.length>1&&s.forEach((e=>{e.equals(t)||(this.adjacentPolygons[e.keyIndex]=e)}))}}}isActiveTriangle(t){return this.activeTriangle[0]&&this.activeTriangle[0].equals(t)}}const u={M90P1:"m90p1",M90P2:"m90p2"};class g{constructor(t,e,s){this.numPoints=t,this.camoDepth=e,this.skipPointGeneration=s}asDict(){return{num_points:this.numPoints,camo_depth:this.camoDepth,skipPointGeneration:this.skipPointGeneration}}}class p{constructor(t){this.canvas=t,this._pattern=u.M90P2,this.patterns={},this._mouseTrackEnabled=!1,this.defaultM90P2Options=new g(100,2,!1),this.patternMap={m90p1:i,m90p2:d},this.ctx=t.getContext("2d"),this._height=Number(t.getAttribute("width")),this._width=Number(t.getAttribute("height")),this._colors=["#6C7C52","#4A4F44","#3B3845","#B2B096"]}set pattern(t){this._pattern=t}set mouseTrackEnabled(t){this._mouseTrackEnabled=t}set width(t){this._width=t}set height(t){this._height=t}set colors(t){this._colors=t}draw(t,e,s,i){if(!this.ctx)return;const n=t||this._width,r=e||this._height,a=s||this._colors,h=i||this.defaultM90P2Options;this.clearCanvas(n,r,a),this.drawPattern(n,r,a,h)}handleMouseMove(t){if(this._mouseTrackEnabled&&this._pattern===u.M90P2){this.getPatternLogic(this._pattern).handleMouseMove(new e(t.clientX,t.clientY))}}startAnimate(){this._pattern===u.M90P2?this.getPatternLogic(this._pattern).startAnimate():console.error(`${this._pattern} doesn't support animation`)}stopAnimate(){this._pattern===u.M90P2?this.getPatternLogic(this._pattern).stopAnimate():console.error(`${this._pattern} doesn't support animation`)}download(){if(!this.canvas)return;let t=document.createElement("a");document.body.appendChild(t),t.setAttribute("download","camo-pattern.png"),t.setAttribute("href",this.canvas.toDataURL("image/png").replace("image/png","image/octet-stream")),t.click(),document.body.removeChild(t)}drawPattern(t,e,s,i){const n=this.getPatternLogic(this._pattern),r=i?i.asDict():{};n.draw(t,e,s,r)}clearCanvas(t,e,s){this.canvas.setAttribute("width",t.toString()),this.canvas.setAttribute("height",e.toString()),this.ctx.fillStyle=s[0],this.ctx.fillRect(0,0,t,e)}getPatternLogic(t){return void 0===this.patterns[t]&&(this.patterns[t]=new this.patternMap[t](this.ctx)),this.patterns[t]}}export{p as CamoPattern,g as CamoPatternM90P2Options,u as Pattern};
